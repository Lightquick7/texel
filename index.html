<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Texel - Dodge</title>
        <style>
            html,
            body {
                margin: 0;
                height: 100%;
                overflow: hidden;
                background: #f0f0f0;
            }
            canvas {
                display: block;
                width: 100vw;
                height: 100vh;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <canvas id="game"></canvas>

        <script>
            const canvas = document.getElementById("game");
            const ctx = canvas.getContext("2d");

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener("resize", resize);
            resize();

            // --- PLAYER (BLUE SQUARE) ---
            const size = 50;
            let x = 100,
                y = 100;
            const speed = 5;

            const keys = {};
            window.addEventListener("keydown", (e) => (keys[e.key] = true));
            window.addEventListener("keyup", (e) => (keys[e.key] = false));

            function clampPlayer() {
                x = Math.max(0, Math.min(canvas.width - size, x));
                y = Math.max(0, Math.min(canvas.height - size, y));
            }

            // --- DRAGGING (MOUSE + TOUCH) ---
            let dragging = false;
            let dragOffsetX = 0;
            let dragOffsetY = 0;

            function getPointerPos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    px: (e.clientX - rect.left) * (canvas.width / rect.width),
                    py: (e.clientY - rect.top) * (canvas.height / rect.height),
                };
            }

            function pointInSquare(px, py) {
                return px >= x && px <= x + size && py >= y && py <= y + size;
            }

            // Allow "grab" if you start near the square (helpful on mobile)
            function nearSquare(px, py) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const dist = Math.hypot(px - cx, py - cy);
                return dist <= 70; // grab radius
            }

            canvas.addEventListener("pointerdown", (e) => {
                const { px, py } = getPointerPos(e);

                if (pointInSquare(px, py) || nearSquare(px, py)) {
                    dragging = true;
                    dragOffsetX = px - x;
                    dragOffsetY = py - y;
                    canvas.setPointerCapture(e.pointerId);
                }
            });

            canvas.addEventListener("pointermove", (e) => {
                if (!dragging) return;
                const { px, py } = getPointerPos(e);

                x = px - dragOffsetX;
                y = py - dragOffsetY;
                clampPlayer();
            });

            canvas.addEventListener("pointerup", (e) => {
                dragging = false;
                try {
                    canvas.releasePointerCapture(e.pointerId);
                } catch {}
            });

            canvas.addEventListener("pointercancel", () => {
                dragging = false;
            });

            // --- ENEMIES (RED CIRCLES) ---
            const enemyCount = 5;
            const enemies = [];
            const r = 18;

            function rand(min, max) {
                return Math.random() * (max - min) + min;
            }

            function circleRectCollides(cx, cy, cr, rx, ry, rw, rh) {
                const closestX = Math.max(rx, Math.min(cx, rx + rw));
                const closestY = Math.max(ry, Math.min(cy, ry + rh));
                const dx = cx - closestX;
                const dy = cy - closestY;
                return dx * dx + dy * dy <= cr * cr;
            }

            function resetEnemies() {
                enemies.length = 0;

                for (let i = 0; i < enemyCount; i++) {
                    let ex, ey;

                    // Spawn not overlapping each other and not too close to player.
                    for (let tries = 0; tries < 200; tries++) {
                        ex = rand(r, canvas.width - r);
                        ey = rand(r, canvas.height - r);

                        const playerDx = ex - (x + size / 2);
                        const playerDy = ey - (y + size / 2);
                        const farFromPlayer =
                            Math.hypot(playerDx, playerDy) > 160;

                        let overlaps = false;
                        for (const o of enemies) {
                            const dx = ex - o.x;
                            const dy = ey - o.y;
                            if (dx * dx + dy * dy < 2 * r * (2 * r)) {
                                overlaps = true;
                                break;
                            }
                        }

                        if (farFromPlayer && !overlaps) break;
                    }

                    let vx = rand(-4, 4);
                    let vy = rand(-4, 4);
                    if (Math.abs(vx) < 1.5) vx = (vx < 0 ? -1 : 1) * 2.5;
                    if (Math.abs(vy) < 1.5) vy = (vy < 0 ? -1 : 1) * 2.5;

                    enemies.push({ x: ex, y: ey, vx, vy, r });
                }
            }

            // --- TIMER ---
            let runStart = performance.now();
            let lastTime = 0;
            let bestTime = 0;

            function restartRun() {
                const now = performance.now();
                lastTime = (now - runStart) / 1000;
                bestTime = Math.max(bestTime, lastTime);

                x = 100;
                y = 100;
                runStart = now;
                resetEnemies();
            }

            resetEnemies();

            // --- PHYSICS: CIRCLE-CIRCLE COLLISION (equal mass) ---
            function resolveCircleCollision(a, b) {
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dist = Math.hypot(dx, dy);
                const minDist = a.r + b.r;

                if (dist === 0 || dist >= minDist) return;

                // Separate
                const nx = dx / dist;
                const ny = dy / dist;
                const overlap = minDist - dist;

                a.x -= nx * (overlap / 2);
                a.y -= ny * (overlap / 2);
                b.x += nx * (overlap / 2);
                b.y += ny * (overlap / 2);

                // Relative velocity
                const rvx = b.vx - a.vx;
                const rvy = b.vy - a.vy;
                const velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) return;

                const restitution = 1.0;
                const j = (-(1 + restitution) * velAlongNormal) / 2;

                const impulseX = j * nx;
                const impulseY = j * ny;

                a.vx -= impulseX;
                a.vy -= impulseY;
                b.vx += impulseX;
                b.vy += impulseY;

                const damp = 0.999;
                a.vx *= damp;
                a.vy *= damp;
                b.vx *= damp;
                b.vy *= damp;
            }

            function update() {
                // Keyboard only when not dragging (so it doesn't fight your finger)
                if (!dragging) {
                    if (keys["ArrowUp"]) y -= speed;
                    if (keys["ArrowDown"]) y += speed;
                    if (keys["ArrowLeft"]) x -= speed;
                    if (keys["ArrowRight"]) x += speed;
                    clampPlayer();
                }

                // Move enemies
                for (const e of enemies) {
                    e.x += e.vx;
                    e.y += e.vy;

                    // Wall bounce
                    if (e.x - e.r <= 0) {
                        e.x = e.r;
                        e.vx *= -1;
                    }
                    if (e.x + e.r >= canvas.width) {
                        e.x = canvas.width - e.r;
                        e.vx *= -1;
                    }
                    if (e.y - e.r <= 0) {
                        e.y = e.r;
                        e.vy *= -1;
                    }
                    if (e.y + e.r >= canvas.height) {
                        e.y = canvas.height - e.r;
                        e.vy *= -1;
                    }
                }

                // Circle-circle collisions
                for (let i = 0; i < enemies.length; i++) {
                    for (let j = i + 1; j < enemies.length; j++) {
                        resolveCircleCollision(enemies[i], enemies[j]);
                    }
                }

                // Enemy hits player -> restart
                for (const e of enemies) {
                    if (circleRectCollides(e.x, e.y, e.r, x, y, size, size)) {
                        restartRun();
                        break;
                    }
                }
            }

            function draw(now) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Enemies
                ctx.fillStyle = "red";
                for (const e of enemies) {
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Player
                ctx.fillStyle = "blue";
                ctx.fillRect(x, y, size, size);

                // HUD
                const t = (now - runStart) / 1000;
                ctx.fillStyle = "rgba(0,0,0,0.75)";
                ctx.font = "16px sans-serif";
                ctx.fillText(`Time: ${t.toFixed(2)}s`, 12, 20);
                ctx.fillText(`Last: ${lastTime.toFixed(2)}s`, 12, 40);
                ctx.fillText(`Best: ${bestTime.toFixed(2)}s`, 12, 60);
                ctx.fillText(
                    `Drag or use arrow keys. Avoid red balls.`,
                    12,
                    84,
                );
            }

            function loop(now) {
                update();
                draw(now);
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        </script>
    </body>
</html>
