<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Texel - Dodge</title>
        <style>
            html,
            body {
                margin: 0;
                height: 100%;
                overflow: hidden;
                background: #f0f0f0;
            }
            canvas {
                display: block;
                width: 100vw;
                height: 100vh;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <canvas id="game"></canvas>

        <script>
            const canvas = document.getElementById("game");
            const ctx = canvas.getContext("2d");

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener("resize", resize);
            resize();

            // --- PLAYER (BLUE SQUARE) ---
            const size = 50;
            let x = 100,
                y = 100;
            const keyboardSpeed = 5; // arrow keys
            const joystickMaxSpeed = 7; // max speed when joystick fully pushed

            const keys = {};
            window.addEventListener("keydown", (e) => (keys[e.key] = true));
            window.addEventListener("keyup", (e) => (keys[e.key] = false));

            function clampPlayer() {
                x = Math.max(0, Math.min(canvas.width - size, x));
                y = Math.max(0, Math.min(canvas.height - size, y));
            }

            // --- POINTER POSITION (supports CSS scaling) ---
            function getPointerPos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    px: (e.clientX - rect.left) * (canvas.width / rect.width),
                    py: (e.clientY - rect.top) * (canvas.height / rect.height),
                };
            }

            // --- DRAGGING THE SQUARE ---
            let draggingSquare = false;
            let dragOffsetX = 0;
            let dragOffsetY = 0;

            function pointInSquare(px, py) {
                return px >= x && px <= x + size && py >= y && py <= y + size;
            }
            function nearSquare(px, py) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                return Math.hypot(px - cx, py - cy) <= 70;
            }

            // --- JOYSTICK (bottom-left) ---
            const joy = {
                active: false,
                pointerId: null,
                baseX: 0,
                baseY: 0,
                baseR: 52, // base radius
                knobX: 0,
                knobY: 0,
                knobR: 20, // knob radius
                dx: 0, // normalized -1..1
                dy: 0, // normalized -1..1
            };

            function layoutJoystick() {
                // Place it with padding from bottom-left
                const pad = 26;
                joy.baseX = pad + joy.baseR;
                joy.baseY = canvas.height - (pad + joy.baseR);
                joy.knobX = joy.baseX;
                joy.knobY = joy.baseY;
            }
            layoutJoystick();

            function resetJoystick() {
                joy.active = false;
                joy.pointerId = null;
                joy.dx = 0;
                joy.dy = 0;
                joy.knobX = joy.baseX;
                joy.knobY = joy.baseY;
            }

            function inJoystickArea(px, py) {
                const d = Math.hypot(px - joy.baseX, py - joy.baseY);
                // Slightly larger than base so itâ€™s easy to grab
                return d <= joy.baseR + 18;
            }

            // Handle resize: keep joystick pinned to bottom-left
            window.addEventListener("resize", () => {
                resize();
                layoutJoystick();
                if (!joy.active) resetJoystick();
            });

            // --- ENEMIES (RED CIRCLES) ---
            const enemyCount = 5;
            const enemies = [];
            const r = 18;

            function rand(min, max) {
                return Math.random() * (max - min) + min;
            }

            function circleRectCollides(cx, cy, cr, rx, ry, rw, rh) {
                const closestX = Math.max(rx, Math.min(cx, rx + rw));
                const closestY = Math.max(ry, Math.min(cy, ry + rh));
                const dx = cx - closestX;
                const dy = cy - closestY;
                return dx * dx + dy * dy <= cr * cr;
            }

            function resetEnemies() {
                enemies.length = 0;
                for (let i = 0; i < enemyCount; i++) {
                    let ex, ey;
                    for (let tries = 0; tries < 200; tries++) {
                        ex = rand(r, canvas.width - r);
                        ey = rand(r, canvas.height - r);

                        const pdx = ex - (x + size / 2);
                        const pdy = ey - (y + size / 2);
                        const farFromPlayer = Math.hypot(pdx, pdy) > 160;

                        let overlaps = false;
                        for (const o of enemies) {
                            const dx = ex - o.x,
                                dy = ey - o.y;
                            if (dx * dx + dy * dy < 2 * r * (2 * r)) {
                                overlaps = true;
                                break;
                            }
                        }
                        if (farFromPlayer && !overlaps) break;
                    }

                    let vx = rand(-4, 4);
                    let vy = rand(-4, 4);
                    if (Math.abs(vx) < 1.5) vx = (vx < 0 ? -1 : 1) * 2.5;
                    if (Math.abs(vy) < 1.5) vy = (vy < 0 ? -1 : 1) * 2.5;

                    enemies.push({ x: ex, y: ey, vx, vy, r });
                }
            }

            function resolveCircleCollision(a, b) {
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dist = Math.hypot(dx, dy);
                const minDist = a.r + b.r;
                if (dist === 0 || dist >= minDist) return;

                const nx = dx / dist,
                    ny = dy / dist;
                const overlap = minDist - dist;

                a.x -= nx * (overlap / 2);
                a.y -= ny * (overlap / 2);
                b.x += nx * (overlap / 2);
                b.y += ny * (overlap / 2);

                const rvx = b.vx - a.vx;
                const rvy = b.vy - a.vy;
                const velAlongNormal = rvx * nx + rvy * ny;
                if (velAlongNormal > 0) return;

                const restitution = 1.0;
                const j = (-(1 + restitution) * velAlongNormal) / 2;

                const impulseX = j * nx;
                const impulseY = j * ny;
                a.vx -= impulseX;
                a.vy -= impulseY;
                b.vx += impulseX;
                b.vy += impulseY;

                const damp = 0.999;
                a.vx *= damp;
                a.vy *= damp;
                b.vx *= damp;
                b.vy *= damp;
            }

            // --- TIMER ---
            let runStart = performance.now();
            let lastTime = 0;
            let bestTime = 0;

            function restartRun() {
                const now = performance.now();
                lastTime = (now - runStart) / 1000;
                bestTime = Math.max(bestTime, lastTime);

                x = 100;
                y = 100;
                clampPlayer();
                runStart = now;
                resetEnemies();
                // keep joystick where it is; but if not active, recenter
                if (!joy.active) resetJoystick();
            }

            resetEnemies();
            resetJoystick();

            // --- POINTER INPUT ROUTING: joystick vs dragging square ---
            canvas.addEventListener("pointerdown", (e) => {
                const { px, py } = getPointerPos(e);

                // If touch/click is in joystick area, start joystick control
                if (inJoystickArea(px, py)) {
                    joy.active = true;
                    joy.pointerId = e.pointerId;
                    canvas.setPointerCapture(e.pointerId);

                    // Update immediately so it feels responsive
                    const dx = px - joy.baseX;
                    const dy = py - joy.baseY;
                    const max = joy.baseR;
                    const len = Math.hypot(dx, dy) || 1;

                    const clampedLen = Math.min(len, max);
                    const nx = dx / len;
                    const ny = dy / len;

                    joy.knobX = joy.baseX + nx * clampedLen;
                    joy.knobY = joy.baseY + ny * clampedLen;

                    joy.dx = (nx * clampedLen) / max; // -1..1
                    joy.dy = (ny * clampedLen) / max; // -1..1
                    return;
                }

                // Otherwise try dragging square
                if (pointInSquare(px, py) || nearSquare(px, py)) {
                    draggingSquare = true;
                    dragOffsetX = px - x;
                    dragOffsetY = py - y;
                    canvas.setPointerCapture(e.pointerId);
                }
            });

            canvas.addEventListener("pointermove", (e) => {
                const { px, py } = getPointerPos(e);

                // Joystick movement (only for the pointer that started it)
                if (joy.active && e.pointerId === joy.pointerId) {
                    const dx = px - joy.baseX;
                    const dy = py - joy.baseY;
                    const max = joy.baseR;

                    const len = Math.hypot(dx, dy) || 1;
                    const clampedLen = Math.min(len, max);
                    const nx = dx / len;
                    const ny = dy / len;

                    joy.knobX = joy.baseX + nx * clampedLen;
                    joy.knobY = joy.baseY + ny * clampedLen;

                    joy.dx = (nx * clampedLen) / max;
                    joy.dy = (ny * clampedLen) / max;
                    return;
                }

                // Dragging square
                if (draggingSquare) {
                    x = px - dragOffsetX;
                    y = py - dragOffsetY;
                    clampPlayer();
                }
            });

            canvas.addEventListener("pointerup", (e) => {
                if (joy.active && e.pointerId === joy.pointerId) {
                    resetJoystick();
                    try {
                        canvas.releasePointerCapture(e.pointerId);
                    } catch {}
                    return;
                }
                draggingSquare = false;
                try {
                    canvas.releasePointerCapture(e.pointerId);
                } catch {}
            });

            canvas.addEventListener("pointercancel", (e) => {
                if (joy.active && e.pointerId === joy.pointerId)
                    resetJoystick();
                draggingSquare = false;
            });

            // --- GAME LOOP ---
            function update() {
                // Player movement priority:
                // 1) joystick if active
                // 2) dragging square
                // 3) keyboard
                if (joy.active) {
                    // dy positive means down on canvas, so it feels natural
                    const len = Math.hypot(joy.dx, joy.dy);
                    if (len > 0) {
                        x += (joy.dx / len) * joystickMaxSpeed;
                        y += (joy.dy / len) * joystickMaxSpeed;
                    }
                    clampPlayer();
                } else if (!draggingSquare) {
                    if (keys["ArrowUp"]) y -= keyboardSpeed;
                    if (keys["ArrowDown"]) y += keyboardSpeed;
                    if (keys["ArrowLeft"]) x -= keyboardSpeed;
                    if (keys["ArrowRight"]) x += keyboardSpeed;
                    clampPlayer();
                }

                // Enemies move
                for (const e of enemies) {
                    e.x += e.vx;
                    e.y += e.vy;

                    if (e.x - e.r <= 0) {
                        e.x = e.r;
                        e.vx *= -1;
                    }
                    if (e.x + e.r >= canvas.width) {
                        e.x = canvas.width - e.r;
                        e.vx *= -1;
                    }
                    if (e.y - e.r <= 0) {
                        e.y = e.r;
                        e.vy *= -1;
                    }
                    if (e.y + e.r >= canvas.height) {
                        e.y = canvas.height - e.r;
                        e.vy *= -1;
                    }
                }

                // Circle-circle collisions
                for (let i = 0; i < enemies.length; i++) {
                    for (let j = i + 1; j < enemies.length; j++) {
                        resolveCircleCollision(enemies[i], enemies[j]);
                    }
                }

                // Enemy hits player -> restart
                for (const e of enemies) {
                    if (circleRectCollides(e.x, e.y, e.r, x, y, size, size)) {
                        restartRun();
                        break;
                    }
                }
            }

            function drawJoystick() {
                // Only draw joystick when on a touch device OR when active
                // (You can remove this condition if you always want it visible)
                const likelyTouch =
                    navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
                if (!likelyTouch && !joy.active) return;

                ctx.save();

                // base
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(joy.baseX, joy.baseY, joy.baseR, 0, Math.PI * 2);
                ctx.fill();

                // knob
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(joy.knobX, joy.knobY, joy.knobR, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function draw(now) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // enemies
                ctx.fillStyle = "red";
                for (const e of enemies) {
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
                    ctx.fill();
                }

                // player
                ctx.fillStyle = "blue";
                ctx.fillRect(x, y, size, size);

                // HUD
                const t = (now - runStart) / 1000;
                ctx.fillStyle = "rgba(0,0,0,0.75)";
                ctx.font = "16px sans-serif";
                ctx.fillText(`Time: ${t.toFixed(2)}s`, 12, 20);
                ctx.fillText(`Last: ${lastTime.toFixed(2)}s`, 12, 40);
                ctx.fillText(`Best: ${bestTime.toFixed(2)}s`, 12, 60);
                ctx.fillText(
                    `Drag square, joystick, or arrow keys. Avoid red balls.`,
                    12,
                    84,
                );

                // joystick overlay
                drawJoystick();
            }

            function loop(now) {
                update();
                draw(now);
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        </script>
    </body>
</html>
