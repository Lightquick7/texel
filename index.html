<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Texel - Dodge</title>
        <style>
            html,
            body {
                margin: 0;
                height: 100%;
                overflow: hidden;
                background: #f0f0f0;
            }
            canvas {
                display: block;
                width: 100vw;
                height: 100vh;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <canvas id="game"></canvas>

        <script>
            const canvas = document.getElementById("game");
            const ctx = canvas.getContext("2d");

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener("resize", resize);
            resize();

            // --- PLAYER (BLUE SQUARE) ---
            const size = 50;
            let x = 100,
                y = 100;
            const speed = 5;

            const keys = {};
            window.addEventListener("keydown", (e) => (keys[e.key] = true));
            window.addEventListener("keyup", (e) => (keys[e.key] = false));

            function clampPlayer() {
                x = Math.max(0, Math.min(canvas.width - size, x));
                y = Math.max(0, Math.min(canvas.height - size, y));
            }

            // Pointer pos (supports CSS scaling)
            function getPointerPos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    px: (e.clientX - rect.left) * (canvas.width / rect.width),
                    py: (e.clientY - rect.top) * (canvas.height / rect.height),
                };
            }

            // --- DRAGGING THE SQUARE (mouse + touch) ---
            let draggingSquare = false;
            let dragOffsetX = 0;
            let dragOffsetY = 0;

            function pointInSquare(px, py) {
                return px >= x && px <= x + size && py >= y && py <= y + size;
            }

            // You asked: 70 -> 2000 (so you can start dragging basically anywhere)
            function nearSquare(px, py) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                return Math.hypot(px - cx, py - cy) <= 2000;
            }

            canvas.addEventListener("pointerdown", (e) => {
                const { px, py } = getPointerPos(e);
                if (pointInSquare(px, py) || nearSquare(px, py)) {
                    draggingSquare = true;
                    dragOffsetX = px - x;
                    dragOffsetY = py - y;
                    canvas.setPointerCapture(e.pointerId);
                }
            });

            canvas.addEventListener("pointermove", (e) => {
                if (!draggingSquare) return;
                const { px, py } = getPointerPos(e);
                x = px - dragOffsetX;
                y = py - dragOffsetY;
                clampPlayer();
            });

            canvas.addEventListener("pointerup", (e) => {
                draggingSquare = false;
                try {
                    canvas.releasePointerCapture(e.pointerId);
                } catch {}
            });

            canvas.addEventListener("pointercancel", () => {
                draggingSquare = false;
            });

            // --- ENEMIES (RED CIRCLES) ---
            const enemies = [];
            const BALL_RADIUS = 25; // you asked: ball size to 25
            const INITIAL_BALLS = 5;

            function rand(min, max) {
                return Math.random() * (max - min) + min;
            }

            function circleRectCollides(cx, cy, cr, rx, ry, rw, rh) {
                const closestX = Math.max(rx, Math.min(cx, rx + rw));
                const closestY = Math.max(ry, Math.min(cy, ry + rh));
                const dx = cx - closestX;
                const dy = cy - closestY;
                return dx * dx + dy * dy <= cr * cr;
            }

            function makeEnemy() {
                const r = BALL_RADIUS;

                // spawn away from player and not overlapping existing balls
                let ex = r,
                    ey = r;

                for (let tries = 0; tries < 400; tries++) {
                    ex = rand(r, canvas.width - r);
                    ey = rand(r, canvas.height - r);

                    const pdx = ex - (x + size / 2);
                    const pdy = ey - (y + size / 2);
                    const farFromPlayer = Math.hypot(pdx, pdy) > 220; // "away from the blue square"

                    let overlaps = false;
                    for (const o of enemies) {
                        const dx = ex - o.x,
                            dy = ey - o.y;
                        const minD = r + o.r;
                        if (dx * dx + dy * dy < minD * minD) {
                            overlaps = true;
                            break;
                        }
                    }

                    if (farFromPlayer && !overlaps) break;
                }

                // velocity (keep it moving)
                let vx = rand(-4, 4);
                let vy = rand(-4, 4);
                if (Math.abs(vx) < 1.5) vx = (vx < 0 ? -1 : 1) * 2.5;
                if (Math.abs(vy) < 1.5) vy = (vy < 0 ? -1 : 1) * 2.5;

                return { x: ex, y: ey, vx, vy, r };
            }

            function resetEnemies() {
                enemies.length = 0;
                for (let i = 0; i < INITIAL_BALLS; i++)
                    enemies.push(makeEnemy());
            }

            // --- PHYSICS: CIRCLE-CIRCLE COLLISION (equal mass) ---
            function resolveCircleCollision(a, b) {
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dist = Math.hypot(dx, dy);
                const minDist = a.r + b.r;
                if (dist === 0 || dist >= minDist) return;

                // separate so they don't stick
                const nx = dx / dist,
                    ny = dy / dist;
                const overlap = minDist - dist;

                a.x -= nx * (overlap / 2);
                a.y -= ny * (overlap / 2);
                b.x += nx * (overlap / 2);
                b.y += ny * (overlap / 2);

                // relative velocity along normal
                const rvx = b.vx - a.vx;
                const rvy = b.vy - a.vy;
                const velAlongNormal = rvx * nx + rvy * ny;
                if (velAlongNormal > 0) return;

                const restitution = 1.0;
                const j = (-(1 + restitution) * velAlongNormal) / 2; // equal masses => /2

                const impulseX = j * nx;
                const impulseY = j * ny;

                a.vx -= impulseX;
                a.vy -= impulseY;
                b.vx += impulseX;
                b.vy += impulseY;

                // tiny damping to avoid jitter explosions
                const damp = 0.999;
                a.vx *= damp;
                a.vy *= damp;
                b.vx *= damp;
                b.vy *= damp;
            }

            // --- TIMER / SCORE + SPAWNING ---
            let runStart = performance.now();
            let lastTime = 0;
            let bestTime = 0;

            const SPAWN_EVERY_MS = 4000; // you asked: every 4 seconds
            let nextSpawnAt = runStart + SPAWN_EVERY_MS;

            function restartRun() {
                const now = performance.now();
                lastTime = (now - runStart) / 1000;
                bestTime = Math.max(bestTime, lastTime);

                x = 100;
                y = 100;
                clampPlayer();

                runStart = now;
                nextSpawnAt = now + SPAWN_EVERY_MS;
                resetEnemies();
            }

            resetEnemies();

            function update(now) {
                // keyboard movement (only when not dragging so it doesn't fight your input)
                if (!draggingSquare) {
                    if (keys["ArrowUp"]) y -= speed;
                    if (keys["ArrowDown"]) y += speed;
                    if (keys["ArrowLeft"]) x -= speed;
                    if (keys["ArrowRight"]) x += speed;
                    clampPlayer();
                }

                // spawn a new ball every 4 seconds (away from player)
                if (now >= nextSpawnAt) {
                    enemies.push(makeEnemy());
                    // handle potential frame skips
                    while (nextSpawnAt <= now) nextSpawnAt += SPAWN_EVERY_MS;
                }

                // move enemies + wall bounce
                for (const e of enemies) {
                    e.x += e.vx;
                    e.y += e.vy;

                    if (e.x - e.r <= 0) {
                        e.x = e.r;
                        e.vx *= -1;
                    }
                    if (e.x + e.r >= canvas.width) {
                        e.x = canvas.width - e.r;
                        e.vx *= -1;
                    }
                    if (e.y - e.r <= 0) {
                        e.y = e.r;
                        e.vy *= -1;
                    }
                    if (e.y + e.r >= canvas.height) {
                        e.y = canvas.height - e.r;
                        e.vy *= -1;
                    }
                }

                // circle-circle collisions
                for (let i = 0; i < enemies.length; i++) {
                    for (let j = i + 1; j < enemies.length; j++) {
                        resolveCircleCollision(enemies[i], enemies[j]);
                    }
                }

                // enemy hits player => restart
                for (const e of enemies) {
                    if (circleRectCollides(e.x, e.y, e.r, x, y, size, size)) {
                        restartRun();
                        break;
                    }
                }
            }

            function draw(now) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // enemies
                ctx.fillStyle = "red";
                for (const e of enemies) {
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
                    ctx.fill();
                }

                // player
                ctx.fillStyle = "blue";
                ctx.fillRect(x, y, size, size);

                // HUD
                const t = (now - runStart) / 1000;
                ctx.fillStyle = "rgba(0,0,0,0.75)";
                ctx.font = "16px sans-serif";
                ctx.fillText(`Time: ${t.toFixed(2)}s`, 12, 20);
                ctx.fillText(`Last: ${lastTime.toFixed(2)}s`, 12, 40);
                ctx.fillText(`Best: ${bestTime.toFixed(2)}s`, 12, 60);
                ctx.fillText(
                    `Drag anywhere or use arrow keys. Avoid red balls.`,
                    12,
                    84,
                );
                ctx.fillText(
                    `Balls: ${enemies.length} (adds 1 every 4s)`,
                    12,
                    104,
                );
            }

            function loop(now) {
                update(now);
                draw(now);
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        </script>
    </body>
</html>
